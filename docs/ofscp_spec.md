# Open Federated Social Communications Protocol (OFSCP)

> **Status:** Draft v0.1 (for implementation feedback)  
> **Audience:** Provider operators, client developers, interoperability testers  
> **Doc history:** Derived from OFSCP architectural diagrams, 2025-03



## 1. Introduction

### 1.1. Goals & Scope

OFSCP defines an application-layer protocol that allows independently operated providers to offer a shared social + messaging experience. The specification focuses on:

* describing the HTTP APIs and payloads providers expose
* describing how clients authenticate, publish, subscribe, and call
* enabling federation between providers with consistent privacy models

Everything in this document uses RFC 2119 keywords (**MUST**, **SHOULD**, etc.).

### 1.2. Terminology

| Term | Description |
| --- | --- |
| **Provider** | A server (e.g., `example.com`) that stores user accounts, groups, channels, and delivers messages for its users. |
| **Client** | Any application acting on behalf of a user (mobile, desktop, bot, gateway). |
| **Group** | A community hosted on a provider that organizes channels and joined users. |
| **Channel** | Logical stream of posts/messages inside a group. |
| **Call Channel** | A channel that can host an active audio/video session. |
| **Home Provider** | Provider where a user account is registered. |
| **Remote Provider** | Other providers participating in federation for a channel, DM, or broadcast. |
| **Device Key** | A cryptographic keypair generated by a client upon login. |
| **Actor** | A user identifier in the format `@handle@domain`. |

---

## 2. Compatibility & Extensibility (Normative)

### 2.1. Protocol versioning

OFSCP protocol versions use **Semantic Versioning** (SemVer): `MAJOR.MINOR.PATCH`.

* **MAJOR** increments indicate breaking changes.
* **MINOR** increments indicate backward-compatible additions.
* **PATCH** increments indicate clarifications and non-behavioral corrections.

Providers **MUST** publish their supported protocol version as `provider.protocolVersion` in the discovery document.

### 2.2. Standard identifier forms

For interoperability, implementations **MUST** use the **URI form** consistently across all endpoints.

* **URI form:** references are absolute HTTPS URLs.

### 2.3. Forward compatibility

To enable evolution without breaking interoperability:

* Clients and providers **MUST** ignore unknown JSON object fields.
* Clients and providers **MUST** ignore unknown event types.
* Unknown `message.type` values **MUST** be rendered as a generic “message” using best-effort content display.

### 2.4. Canonical identifiers

Objects commonly include an `id`. For cross-provider interoperability, implementations **MUST** treat IDs as **opaque**.

To avoid collisions, implementations **MUST** use **URI identifiers**: globally unique, stable URLs (e.g. `https://social.example/api/messages/msg_123`).

Within this document, examples may show short IDs (e.g. `msg_1`) for readability.

### 2.5. Canonical data formats

* Timestamps **MUST** be RFC 3339 / ISO-8601 strings with timezone (UTC recommended), e.g. `2025-03-01T12:00:00Z`.
* `mime` values **MUST** be valid IANA media types.
* Pagination cursors **MUST** be treated as opaque strings.

Providers **SHOULD** define maximum payload sizes (request and response) and return **413** when exceeded.

### 2.6. Standard error envelope

Providers **SHOULD** return errors using RFC 7807 Problem Details (`application/problem+json`) with stable `type` URIs.

Providers **MAY** additionally include an `errorCode` field for machine-friendly, stable short codes.

---

## 3. Provider Discovery

### 3.1. Well-known endpoint

Every provider **MUST** host a discovery document at:

```
GET https://{provider}/.well-known/ofscp-provider
Content-Type: application/json
```

**Response:**
```json
{
  "provider": {
    "domain": "social.example",
    "protocolVersion": "0.1.0",
    "software": {
      "name": "example-ofscp",
      "version": "2025.03.0"
    },
    "contact": "mailto:admin@social.example",
    "authentication": {
      "login_endpoint": "https://social.example/api/auth/login",
      "registration_endpoint": "https://social.example/api/auth/register"
    }
  },
  "capabilities": {
    "messageTypes": ["memo", "article", "message", "reaction"],
    "discoverability": ["private", "group", "public", "discoverable"],
    "metadataSchemas": [
      {
        "id": "com.example.poll",
        "uri": "https://social.example/meta/poll.json"
      }
    ]

  }
}
```

Providers **MUST** include a `protocolVersion` matching this specification’s SemVer rules.

Clients **MAY** cache discovery documents, but providers **SHOULD** set HTTP caching headers (e.g. `Cache-Control`, `ETag`).

### 3.2. Standard API base path (Normative)

To simplify client implementation and improve interoperability, OFSCP **standardizes** the HTTP API endpoint paths.

Providers **MUST** implement the standard endpoints exactly as specified in this document, relative to their domain (e.g. `https://{provider}`), and **MUST NOT** require clients to read per-resource endpoint URLs from discovery for core APIs.

The base path for all standardized HTTP APIs is:

* `https://{provider}/api/...`

Providers **MAY** expose additional, non-standard endpoints, but those endpoints are out of scope for this specification.

### 3.3. Provider Descriptor Schema

The discovery payload above is the canonical schema.

Discovery is intended to communicate provider identity, supported protocol version, authentication verification parameters, and optional capability metadata.

Discovery **MUST NOT** be used to redefine the standardized endpoint paths in this specification.

### 3.4. Provider Interconnection

Providers **MAY** maintain a list of "Known Providers" to facilitate federation. This list can optionally be populated via:
1.  **Manual Peering:** Administrators explicitly adding trusted domains.
2.  **Scraping:** Discovering user home domains from incoming cross-provider interactions.
3.  **Referral:** Querying other providers for their known peers.

---

## 4. Identity & Authentication

This section specifies the authentication model for OFSCP. The design prioritizes device-level keypairs for all authenticated interactions, ensuring consistency between home and remote provider communication.

### 4.1. Local Authentication (Home Provider)

#### 4.1.1. Registration

1. Client sends `handle` and `password` to home provider at `POST /api/auth/register`.
2. Provider hashes password with Argon2id and stores user information.
3. Provider returns success; client proceeds to device key registration (§4.2).

#### 4.1.2. Login

1. Client sends `handle` and `password` to home provider at `POST /api/auth/login`.
2. Provider verifies password against stored hash.
3. On success, client proceeds to device key registration (§4.2).

#### 4.1.3. Password Requirements

- Minimum 8 characters (RECOMMENDED).
- Providers MAY enforce additional complexity rules.
- Passwords MUST be hashed with Argon2id using:
  - Memory: 64 MiB (minimum)
  - Iterations: 3 (minimum)
  - Parallelism: 4
  - Salt: 16 bytes (minimum), randomly generated per-password

### 4.2. Device Key Registration

Upon successful registration or login, the client registers a device key. **All subsequent authenticated requests to any provider MUST be signed using this key.**

#### 4.2.1. Key Generation

1. Client generates an Ed25519 keypair.
2. Client sends to home provider at `POST /api/auth/device-keys`:
   ```json
   {
     "public_key": "<base64-encoded public key>",
     "device_name": "Firefox on Linux"
   }
   ```
3. Provider stores the key and returns a `key_id`.

#### 4.2.2. Key Storage

Providers MUST store for each device key:
- `key_id`: Unique identifier (provider-generated)
- `user_handle`: Associated user handle
- `public_key`: Ed25519 public key (base64)
- `device_name`: Human-readable device description
- `created_at`: Registration timestamp
- `revoked`: Boolean status

#### 4.2.3. Key Algorithms

- **REQUIRED**: Ed25519 (recommended default)
- **OPTIONAL**: ECDSA P-256, RSA-2048 (for compatibility)

### 4.3. Authenticated Requests (Request Signing)

Every request requiring authentication (to either a home or remote provider) MUST be signed.

#### 4.3.1. Request Signing Headers

Clients MUST include the following headers:
- `X-OFSCP-Actor`: The identifier (e.g., `@alice@providerA.com`)
- `X-OFSCP-Key-ID`: The registered `key_id`
- `X-OFSCP-Timestamp`: RFC 3339 timestamp
- `X-OFSCP-Signature`: Base64-encoded signature

#### 4.3.2. Signature Construction

The signature is computed over a canonical string:
```
<method>\n
<path>\n
<timestamp>\n
<body-sha256>
```

The signature is the Ed25519 signature of this string, base64-encoded.

### 4.4. Signature Verification

Providers receiving a signed request MUST:

1. Extract `X-OFSCP-Actor` and `X-OFSCP-Key-ID`.
2. Fetch the actor's public keys (§4.5).
3. Find the key matching `X-OFSCP-Key-ID`.
4. Verify the signature against the canonical string.
5. Check that `X-OFSCP-Timestamp` is within 5 minutes of current time.

### 4.5. Public Key Discovery

Home providers MUST expose an endpoint for fetching user public keys:
`GET /.well-known/ofscp/users/{handle}/keys`

Response:
```json
{
  "actor": "@alice@providerA.com",
  "keys": [
    {
      "key_id": "dk_abc123xyz",
      "algorithm": "Ed25519",
      "public_key": "<base64-encoded public key>",
      "created_at": "2026-01-09T17:56:54Z"
    }
  ],
  "cache_until": "2026-01-09T18:56:54Z"
}
```

### 4.6. Key Management

Users SHOULD be able to view and MUST be able to revoke individual device keys via their home provider.

#### 4.6.1. Revocation

Upon revocation:
- The key is marked as revoked in storage.
- The key is removed from the public keys endpoint.
- Remote providers with cached revoked keys will fail verification and re-fetch.

#### 4.6.2. Logout

On logout, clients SHOULD request key revocation from their home provider and MUST delete the local private key.



---

## 5. Data Models

### 5.1. User

Users have both *public profile* fields and *private account settings* fields.

Providers **MUST NOT** expose private account fields to unauthenticated parties.

Providers **SHOULD NOT** include private account fields in federated lookups.

Additionally, some user-adjacent data (notably: presence, bio, and group membership visibility) may have user-configurable privacy settings. To avoid accidental leakage, providers **MUST** expose these via dedicated endpoints that apply the subject’s privacy policy when returning data to a viewer. See [section 6](#6-user-privacy-endpoints-profile-presence-membership-listing) for more details.

#### 5.1.1. UserProfile (public)

`UserProfile` is the minimal, safe-to-share representation of a user used in membership lists, message author fields, and federated lookups.

**UserProfile (example):**
```json
{
  "id": "https://a.com/api/users/usr_123",
  "handle": "jane",
  "domain": "a.com",
  "displayName": "Jane Doe",
  "avatar": "https://cdn...",

  "updatedAt": "2025-03-01T12:00:00Z",
  "metadata": []
}
```

#### 5.1.2. UserAccount (private, not federated)

`UserAccount` is returned only to the authenticated user (e.g. via a `/me` endpoint). It may include provider-specific settings.

**UserAccount (example):**
```json
{
  "profile": {
    "id": "https://a.com/api/users/usr_123",
    "handle": "jane",
    "domain": "a.com",
    "displayName": "Jane Doe",
    "avatar": "https://cdn...",
    "updatedAt": "2025-03-01T12:00:00Z",
    "metadata": []
  },
  "settings": {
    "theme": "dark"
  }
}
```

### 5.3. Group & Channels
```json
{
  "id": "grp_1",
  "name": "Dev Guild",
  "owner": "usr_123@a.com",
  "permissions": {
    "post": ["member"],
    "moderate": ["admin"]
  },
  "channels": [
    {
      "id": "chn_general",
      "type": "text",
      "discoverability": "public",
      "tags": ["announcements"],
      "metadata": []
    },
    {
      "id": "chn_voice",
      "type": "call",
      "discoverability": "group",
      "call": {
        "active": false,
        "participants": []
      },
      "metadata": []
    }
  ]
}
```

### 5.3. Message Objects

**Chat**

Chats are intended for short, real-time communications between users.

```json
{
  "id": "msg_1",
  "author": "jane@a.com",
  "type": "message",
  "content": {
    "text": "Hello",
    "mime": "text/plain"
  },
  "attachments": [
    {
      "id": "att_1",
      "mime": "image/png",
      "url": "https://cdn...",
      "size": 2048
    }
  ],
  "reference": {
    "type": "reply",
    "id": "msg_parent"
  },
  "tags": ["#intro"],
  "createdAt": "2025-03-01T12:00:00Z",
  "permissions": {
    "editUntil": "2025-03-01T13:00:00Z"
  },
  "metadata": []
}
```

**Memo**

Memos are intended to be short-form posts similar to many social media platforms.

```json
{
  "id": "msg_2",
  "author": "jane@a.com",
  "type": "memo",
  "content": {
    "text": "Hi everyone...",
    "mime": "text/plain"
  },
  "attachments": [
    {
      "id": "att_1",
      "mime": "image/png",
      "url": "https://cdn...",
      "size": 2048
    }
  ],
  "reference": {
    "type": "reply",
    "id": "msg_parent"
  },
  "tags": ["#intro"],
  "createdAt": "2025-03-01T12:00:00Z",
  "permissions": {
    "editUntil": "2025-03-01T13:00:00Z"
  },
  "metadata": []
}
```

**Article**

Articles are intended to be long-form posts similar to what you might find on a blog or forum. They can be formatted with html or markdown, and are allowed to embed images or other remote content.

```json
{
  "id": "msg_3",
  "author": "jane@a.com",
  "type": "article",
  "content": {
    "text": "# Welcome to...",
    "mime": "text/markdown"
  },
  "attachments": [
    {
      "id": "att_1",
      "mime": "image/png",
      "url": "https://cdn...",
      "size": 2048
    }
  ],
  "reference": {
    "type": "reply",
    "id": "msg_parent"
  },
  "tags": ["#intro"],
  "createdAt": "2025-03-01T12:00:00Z",
  "permissions": {
    "editUntil": "2025-03-01T13:00:00Z"
  },
  "metadata": []
}
```

**Reaction**

Reactions allow users to interact with other message objects by adding a unicode character (usually an emoji), image, or GIF.

Clients **SHOULD** format reactions within their associated messages.

```json
{
  "id": "rct_1",
  "author": "jane@a.com",
  "key": "heart",
  "unicode": "❤️",
  "image": "https://cdn...",
  "reference": {
    "type": "message",
    "id": "msg_id"
  },
  "createdAt": "2025-03-01T12:00:00Z",
  "metadata": []
}
```

### 5.4. Metadata Objects

Metadata can be attached to most objects to implement custom features. Such features **MUST** provide a public JSON Schema and **MUST** be implemented in such a way that ignoring the metadata will still result in a readable experience.

```json
{
  "schema": "https://a.com/schemas/poll",
  "version": "1.0",
  "data": {
    "question": "lunch?",
    "options": ["tacos", "ramen"]
  }
}
```

### 5.5. Group Endpoints

#### GET /api/groups/{groupId}

Fetches metadata for a single group.

**Authorization:**
- Public groups (`discoverability: "public"` or `"discoverable"`): No authentication required
- Private groups (`discoverability: "private"` or `"group"`): Requires valid authentication and the caller must be a group member

**Response (200 OK):**
```json
{
  "id": "grp_abc123",
  "name": "My Group",
  "description": "A group for discussion",
  "owner": "@alice@provider.example",
  "joinPolicy": "open",
  "discoverability": "public",
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-01-15T10:30:00Z"
}
```

**Errors:**
- `404 Not Found`: Group does not exist
- `403 Forbidden`: Private group and caller is not a member

**Federation:** Remote providers MAY query this endpoint to display group info to users considering joining. Providers MUST enforce discoverability rules for federated requests.

---

## 6. User Privacy Endpoints (Profile, Presence, Membership Listing)

To support per-user privacy controls without overloading `UserProfile` fields, providers **MUST** implement the following endpoints.

### 6.1. Visibility policy (shared)

When a subject configures privacy for presence, profile extras (e.g. bio), or group memberships, providers **MUST** represent visibility using a small shared enum, with the values:

* `public` — visible to anyone
* `authenticated` — visible to any authenticated user
* `sharedGroups` — visible only to viewers who share at least one group with the subject
* `contacts` — visible only to DM contacts
* `nobody` — visible to no one except the subject (and administrators as required)

Providers **SHOULD** also implement an `allowList` and `denyList` that will override the privacy setting for users in these lists.

### 6.2. Public profile endpoint

```http
GET /api/users/{userRef}/profile
Authorization: Bearer <token>
```

**Response:** A `UserProfile` plus optional profile extras (such as `bio`) filtered by the subject’s profile visibility policy.

Example response:
```json
{
  "id": "https://a.com/api/users/usr_123",
  "handle": "jane",
  "domain": "a.com",
  "displayName": "Jane Doe",
  "avatar": "https://cdn...",
  "bio": "Hello!",
  "updatedAt": "2025-03-01T12:00:00Z",
  "metadata": []
}
```

### 6.3. Update my profile

```http
PATCH /api/me/profile
Authorization: Bearer <token>
Content-Type: application/json
```

Example request:
```json
{
  "displayName": "Jane Doe",
  "avatar": "https://cdn...",
  "bio": "Hello!",
  "metadata": []
}
```

### 6.4. Presence endpoint

```http
GET /api/users/{userRef}/presence
Authorization: Bearer <token>
```

Presence data returned **MUST** be filtered by the subject’s presence visibility policy.

Example response:
```json
{
  "availability": "online",
  "status": "Grinding @ work :/",
  "lastSeen": "2025-03-01T12:00:00Z",
  "metadata": []
}
```

Update my presence:
```http
PUT /api/me/presence
Authorization: Bearer <token>
Content-Type: application/json
```

Example request:
```json
{
  "availability": "away",
  "status": "On vacation, see ya! ;)",
  "metadata": []
}
```

### 6.5. Group memberships visible to viewer

```http
GET /api/users/{userRef}/groups
Authorization: Bearer <token>
```

Response **MUST** only include groups visible to the viewer per the subject’s membership visibility settings.

Example response:
```json
{
  "groups": [
    {
      "id": "https://a.com/api/groups/grp_1"
    }
  ],
  "metadata": []
}
```

### 6.6. Visibility settings (private)

Providers **SHOULD** allow users to configure visibility for presence, bio/profile extras, and membership listing.

```http
GET /api/me/privacy
Authorization: Bearer <token>
```

Example response:
```json
{
  "presenceVisibility": "sharedGroups",
  "profileVisibility": "public",
  "membershipVisibility": "contacts",
  "metadata": []
}
```

Update:
```http
PUT /api/me/privacy
Authorization: Bearer <token>
Content-Type: application/json
```

Example request:
```json
{
  "presenceVisibility": "sharedGroups",
  "profileVisibility": "public",
  "membershipVisibility": "contacts",
  "metadata": []
}
```

---

## 7. Messaging Lifecycle

### 7.1. WebSocket real-time messaging (Normative)

OFSCP standardizes real-time messaging over **WebSockets**.

Providers **MUST** expose a WebSocket endpoint at:

```
wss://{providerDomain}/api/ws
```

#### Authentication

Connections **MUST** be authenticated.

* Clients MUST sign the upgrade request headers per §4.3.

Providers **MUST** close the connection if authentication fails.

#### WebSocket message envelope

All client→server commands and server→client events **MUST** use this JSON envelope:

```json
{
  "id": "evt_or_cli_id",
  "type": "message.created",
  "ts": "2026-01-01T12:00:00Z",
  "correlationId": "optional_client_id",
  "data": {}
}
```

Rules:

* `id` **MUST** be unique within a connection.
* `type` **MUST** be a stable string.
* `ts` **MUST** be an RFC3339 timestamp.
* `correlationId` **SHOULD** be included in responses that correspond to a specific client request.

Clients **MUST** ignore unknown fields.

#### WebSocket message types (Normative)

All WebSocket payloads **MUST** use the message envelope described above.

The `type` field **MUST** be one of the following standardized strings.

##### Client → Server command types

| type | Description | data schema |
| --- | --- | --- |
| `subscribe` | Subscribe this connection to one or more channel streams. | `WsSubscribe` |
| `unsubscribe` | Unsubscribe this connection from one or more channel streams. | `WsUnsubscribe` |
| `message.create` | Create (post) a message into a channel timeline. | `WsMessageCreate` |
| `typing.start` | Signal typing started in a channel (ephemeral). | `WsTypingStart` |
| `typing.stop` | Signal typing stopped in a channel (ephemeral). | `WsTypingStop` |

##### Server → Client event types

| type | Description | data schema |
| --- | --- | --- |
| `subscribed` | Acknowledgement of a successful `subscribe`. | `WsSubscribed` |
| `unsubscribed` | Acknowledgement of a successful `unsubscribe`. | `WsUnsubscribed` |
| `message.created` | A message was created in a subscribed channel. | `WsMessageCreated` |
| `message.updated` | A message was updated in a subscribed channel. | `WsMessageUpdated` |
| `message.deleted` | A message was deleted in a subscribed channel. | `WsMessageDeleted` |
| `channel.typing` | Typing indicator event for a channel. | `WsChannelTyping` |
| `error` | Request-scoped error response. | `WsError` |

Rules:

* Providers **MUST** implement all event types listed above that correspond to the commands they support.
  * Example: a provider that supports `message.create` **MUST** emit `message.created`.
* Providers **MAY** emit additional `type` values; clients **MUST** ignore unknown types.
* For request/response style interactions (e.g. `subscribe`, `message.create`), providers **SHOULD** echo the client’s request `id` in `correlationId`.

#### Subscriptions

Clients **MUST** subscribe to one or more channels to receive message and typing events.

Client → Server:
```json
{
  "id": "cli_001",
  "type": "subscribe",
  "data": {
    "channels": ["chn_general"],
    "include": ["message.created", "message.updated", "message.deleted", "channel.typing"]
  }
}
```

Server → Client:
```json
{
  "id": "evt_100",
  "type": "subscribed",
  "correlationId": "cli_001",
  "ts": "2026-01-01T12:00:00Z",
  "data": { "channels": ["chn_general"] }
}
```

Providers **MUST** enforce authorization at subscription-time and reject unauthorized subscriptions.

Unsubscribe:
```json
{
  "id": "cli_002",
  "type": "unsubscribe",
  "data": { "channels": ["chn_general"] }
}
```

#### Sending messages

Posting a message is a WebSocket command.

Client → Server:
```json
{
  "id": "cli_200",
  "type": "message.create",
  "data": {
    "groupId": "grp_1",
    "channelId": "chn_general",
    "clientMessageId": "cmsg_abc123",
    "content": { "type": "text/plain", "text": "hi" }
  }
}
```

Server → Client event (fan-out to all subscribed clients, including the author):
```json
{
  "id": "evt_201",
  "type": "message.created",
  "correlationId": "cli_200",
  "ts": "2026-01-01T12:00:00Z",
  "data": {
    "groupId": "grp_1",
    "channelId": "chn_general",
    "message": {
      "id": "msg_999",
      "clientMessageId": "cmsg_abc123",
      "author": "user:alice",
      "createdAt": "2026-01-01T12:00:00Z",
      "content": { "type": "text/plain", "text": "hi" }
    }
  }
}
```

Idempotency:

* Clients **SHOULD** set `clientMessageId`.
* Providers **MUST** treat `(author, channelId, clientMessageId)` as idempotent and respond with the canonical message if a duplicate is received.

#### Typing indicators

Client → Server:
```json
{ "id": "cli_300", "type": "typing.start", "data": { "channelId": "chn_general" } }
```

Server → Subscribers:
```json
{
  "id": "evt_301",
  "type": "channel.typing",
  "ts": "2026-01-01T12:00:00Z",
  "data": { "channelId": "chn_general", "user": "user:alice", "state": "start" }
}
```

### 7.2. Reading

Pagination cursors **MUST** be opaque strings returned by the server.

```
GET /api/groups/{groupId}/channels/{channelId}/messages?cursor=opaqueCursorValue&direction=backward&limit=50
```

Response example:
```json
{
  "items": [],
  "page": {
    "nextCursor": "opaqueNextCursor",
    "prevCursor": "opaquePrevCursor"
  }
}
```

### 7.3. Error semantics

Providers **SHOULD** return errors using RFC 7807 Problem Details (`application/problem+json`) with stable `type` values.

Example:
```json
{
  "type": "https://ofscp.example/errors/invalid-payload",
  "title": "Invalid payload",
  "status": 400,
  "detail": "Field 'content.text' is required",
  "instance": "/api/groups/grp_1/channels/chn_general/messages"
}
```

Common status codes:

| Status | Meaning |
| --- | --- |
| 400 | Invalid payload/schema mismatch |
| 401 | Missing/invalid token |
| 403 | Permission denied |
| 404 | Channel or message not found |
| 409 | Duplicate client message ID |
| 503 | Provider temporarily unavailable |

#### WebSocket error messages

Providers **SHOULD** return errors as WebSocket messages with `type: "error"`.

Example:
```json
{
  "id": "evt_err_1",
  "type": "error",
  "correlationId": "cli_200",
  "ts": "2026-01-01T12:00:00Z",
  "data": {
    "code": "forbidden",
    "message": "No access to channel chn_general",
    "status": 403
  }
}
```

---

## 8. Federation Rules

Federated (provider-to-provider) requests and client-to-remote-provider requests **MUST** be authenticated using **Ed25519 Request Signing** as defined in §4.3.

* Providers **MUST** expose user public keys at the keys endpoint (§4.4).
* Recipients **MUST** enforce a maximum clock skew for the `X-OFSCP-Timestamp` header (RECOMMENDED: 300 seconds).

The covered components for the signature MUST include method, path, timestamp, and body hash (§4.3.2).

#### Replay prevention

Recipients **MUST** reject requests that are outside the allowed clock skew window.
Recipients **SHOULD** additionally implement replay detection for a short window (RECOMMENDED: 5 minutes), keyed by `(providerDomain, signature, @created)`.

#### Authorization

Authentication proves the calling provider domain; authorization is still required:

* Providers **MUST** apply allow/deny policy for which remote providers may federate.
* Providers **MUST** enforce channel/group privacy tiers when serving federation traffic.

### 8.1. Remote channel participation

* Remote users access a channel via `POST /api/groups/{groupId}/channels/{channelId}/join` on the channel’s home provider.
* Home provider authenticates the remote user by calling their home provider’s discovery document and verifying signed federation requests.

### 8.2. Direct messages

* **Source of Truth:** The recipient's home provider acts as the authoritative store for a user's inbox.
* **Client-to-Remote Delivery:** Clients **MUST** deliver DMs directly to the recipient's home provider via `POST /api/federation/dms/{dmId}/messages`.
* **Storage:** The recipient's provider stores the message.

### 8.3. Broadcast & discoverability

* Channels marked `discoverable` publish a feed at `GET /api/groups/{groupId}/channels/{channelId}/discoverable`. Remote providers subscribe using WebSub-like callbacks.
* Receiving providers decide whether to display, ignore, or re-rank discoverable content but **MUST** respect the channel’s privacy tier.

---

## 9. Real-time Calls

### 9.1. Call channel state

```json
{
  "channel": "chn_voice",
  "call": {
    "state": "inactive",
    "participants": [
      {
        "user": "jane@a.com",
        "role": "host",
        "media": {
          "audio": "opus",
          "video": "vp9"
        }
      }
    ],
    "metadata": []
  }
}
```

### 9.2. Control APIs (Signaling)

These endpoints act as the signaling plane. Payloads are ephemeral and not persisted in the channel timeline.

* `POST /api/groups/{groupId}/channels/{channelId}/call/offer` – client submits WebRTC offer SDP.
* `POST /api/groups/{groupId}/channels/{channelId}/call/answer` – provider validates and relays to other participants.
* `POST /api/groups/{groupId}/channels/{channelId}/call/ice` – trickle ICE exchange.
* Providers **MUST** ensure only one `active` session per call channel; attempts to start another result in **409**.

Consumers exchange media peer-to-peer; providers act as signaling coordinators only.

---

## 10. Notifications

Providers expose a webhook registration API:
```
POST /api/notifications/endpoints
{
  "type": "webpush",
  "target": "https://push-service",
  "events": ["message.created", "call.started"]
}
```

Delivery payload:
```json
{
  "event": "message.created",
  "resource": {
    "id": "msg_1",
    "channel": "chn_general"
  },
  "provider": "a.com",
  "signature": "base64"
}
```

---

## 11. Privacy & Discoverability Tiers

Privacy tiers are configured on a **per-channel** basis.

Providers **MAY** define their own set of privacy tiers to suit their community needs. However, all providers **MUST** support a `private` tier.

The following table lists **examples** of common configurations (non-normative suggestions):

| Tier | Description | Rules |
| --- | --- | --- |
| Private | Invite-only | No federation, no broadcast. |
| Group | Accessible to group members |  No federation, no broadcast. |
| Public | Visible to anyone with link | Read-only without join, but not broadcast. |
| Discoverable | Searchable and syndicated | Providers publish updates to subscribers. |

### 11.1. Tier Discovery

Providers **MUST** expose an endpoint (referenced in the discovery document) to list available tiers and their descriptions so clients can render them appropriately.

```
GET /api/tiers
```

**Response:**
```json
{
  "tiers": [
    {
      "id": "private",
      "name": "Private",
      "description": "Only invited members can see this channel."
    },
    {
      "id": "public",
      "name": "Public",
      "description": "Visible to anyone with the link."
    }
  ]
}
```

Clients **MUST** surface these tiers and allow owners to change them (subject to provider policy).

---

## 12. Compliance Checklist

### Provider **MUST**

- [ ] Support password-based registration and login
- [ ] Implement device key registration and revocation
- [ ] Validate Ed25519 request signatures for all authenticated requests
- [ ] Serve user public keys via the `/.well-known/ofscp/users/{handle}/keys` endpoint
- [ ] Support message fan-out + notification endpoints
- [ ] Enforce privacy tiers per channel
- [ ] Support 'private' channel tier
- [ ] Expose `GET /tiers` endpoint
- [ ] Provide metadata schema registry (optional entries allowed)

### Client **MUST**

- [ ] Support Ed25519 request signing for all authenticated requests
- [ ] Support all message types or graceful fallback

### Client **SHOULD**

- [ ] Render metadata extensions when schemas known
- [ ] Provide UX for discoverability + privacy tiers
- [ ] Handle federation latency + retries

---

## Appendix A: Example Flows

### A.1 Registration Flow

```
Client                          Home Provider
   |                                  |
   |  POST /api/auth/register         |
   |  {handle, password}              |
   |--------------------------------->|
   |                                  |  hash password
   |                                  |  store user
   |  200 OK                          |
   |<---------------------------------|
   |                                  |
   |  POST /api/auth/device-keys      |
   |  {public_key, device_name}       |
   |--------------------------------->|
   |                                  |  store device key
   |  {key_id}                        |
   |<---------------------------------|
```

### A.2 Authenticated Request Flow

```
Client                Remote Provider              Home Provider
   |                        |                            |
   |  POST /api/resource    |                            |
   |  (signed request)      |                            |
   |----------------------->|                            |
   |                        |  GET /.well-known/ofscp/   |
   |                        |    users/alice/keys        |
   |                        |--------------------------->|
   |                        |                            |
   |                        |  {keys: [...]}             |
   |                        |<---------------------------|
   |                        |                            |
   |                        |  verify signature          |
   |  200 OK                |                            |
   |<-----------------------|                            |
```

## 13. Future Work

* Rich moderation APIs (ban lists, reporting)
* Media relay + SFU guidelines for large calls
* Schema registry governance
* Interop test suite & conformance badges

Feedback welcome via issues or direct contact in the discovery document.
